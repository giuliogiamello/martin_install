*******************************************************************
* Copyright (C) 2009-2023 Joachim Brod, Emmanuel Stamou
*
* This file is part of MaRTIn.
*
* MaRTIn is lisenced under GPLv3. For further details see the AUTHORS
* file in the main MaRTIn directory.
*******************************************************************

* The notation is Tcol(i,j,a) = (T^a)_ij

***************************************
* generate indices
***************************************
* The fermion vertices
* We replace the vertex indices generated by qgraf by FORM indices:
* fundamental:  n -> in
* fundamental: -n -> jn
* adjoint:  n -> an
* adjoint: -n -> bn

*** Dcols ***************
dimension NcolF;
repeat;
   id Dcol(?a,xx1?pos_,?b) = Dcol(?a,npos(+xx1),?b);
   id Dcol(?a,xx1?neg_,?b) = Dcol(?a,nneg(-xx1),?b);
endrepeat;
repeat id Dcol(?a,npos(xx1?),?b) = Dcol(?a,ii[xx1],?b);
id Dcol(nneg(xx1?),?b) = Dcol(JJ[xx1],?b);
id Dcol(?a,nneg(xx1?)) = Dcol(?a,jj[xx1]);
id Dcol(uu1?,uu2?) = d_(uu1,uu2);

.sort

*** Dadcols *************
dimension NcolA;
repeat;
   id Dadcol(?a,xx1?pos_,?b) = Dadcol(?a,npos(+xx1),?b);
   id Dadcol(?a,xx1?neg_,?b) = Dadcol(?a,nneg(-xx1),?b);
endrepeat;
repeat;
   id Dadcol(?a,npos(xx1?),?b) = Dadcol(?a,aaa[xx1],?b);
   id Dadcol(?a,nneg(xx1?),?b) = Dadcol(?a,bbb[xx1],?b);
endrepeat;
id Dadcol(uu1?,uu2?) = d_(uu1,uu2);

.sort

*** Tcol ****************
repeat;
   id Tcol(?a,xx1?pos_,?b) = Tcol(?a,npos(+xx1),?b);
   id Tcol(?a,xx1?neg_,?b) = Tcol(?a,nneg(-xx1),?b);
endrepeat;

id Tcol(npos(xx1?),?b) = Tcol(ii[xx1],?b);
id Tcol(nneg(xx1?),?b) = Tcol(JJ[xx1],?b);

id Tcol(I1?,npos(xx1?),?b) = Tcol(I1,ii[xx1],?b);
id Tcol(I1?,nneg(xx1?),?b) = Tcol(I1,jj[xx1],?b);

id Tcol(I1?,i1?,npos(xx1?)) = Tcol(I1,i1,aaa[xx1]);
id Tcol(I1?,i1?,nneg(xx1?)) = Tcol(I1,i1,bbb[xx1]);

*** Fcol ***************
repeat;
   id Fcol(?a,xx1?pos_,?b) = Fcol(?a,npos(+xx1),?b);
   id Fcol(?a,xx1?neg_,?b) = Fcol(?a,nneg(-xx1),?b);
endrepeat;
repeat;
   id Fcol(?a,npos(xx1?),?b) = Fcol(?a,aaa[xx1],?b);
   id Fcol(?a,nneg(xx1?),?b) = Fcol(?a,bbb[xx1],?b);
endrepeat;
id Fcol(uu1?,uu2?,uu3?) = fcol(uu1,uu2,uu3);


*** Cold ***************
repeat;
   id Cold(?a,xx1?pos_,?b) = Cold(?a,npos(+xx1),?b);
   id Cold(?a,xx1?neg_,?b) = Cold(?a,nneg(-xx1),?b);
endrepeat;
repeat;
   id Cold(?a,npos(xx1?),?b) = Cold(?a,aaa[xx1],?b);
   id Cold(?a,nneg(xx1?),?b) = Cold(?a,bbb[xx1],?b);
endrepeat;
id Cold(uu1?,uu2?,uu3?) = cold(uu1,uu2,uu3);

.sort

***************************************
* sum over internal indices
***************************************

* a little warning: if until now you have not properly generated
* all your indices the following will lead to something that makes
* no sense

dimension NcolF;
sum i1,...,i20;
sum I1,...,I20;
.sort

dimension NcolA;
sum a1,...,a20;
.sort

dimension d;
sum nu1,...,nu20;
.sort

* WARNING: unfortunately the dummy indices in FORM always take the default/current
* dimension in the module. So it way be nice that above we changed the dimension
* prior to summing but after the last "dimension d" all dummy indices have dimension
* "d".



*** Contraction
*
* The first part should remove contracted Tcols in favour
* of fcol's and cold's. Vermaseren would do it in a different (better) way

* Note: unfortunately we must be careful when within one module both d_(a1,a2)
* and d_(i1,i2) appear, because if any of those indices is a dummy index it always
* takes the default dimension in FORM.

* we set the default dimension to the adjoint and will treat the indices
* in the fundamental with stupid dcol's

.sort
dimension NcolA;
repeat;
  id Tcol(i1?,i2?,a1?) * dcol(i2?,i3?) = Tcol(i1,i3,a1);
  id Tcol(i1?,i2?,a1?) * dcol(i1?,i3?) = Tcol(i3,i2,a1);

* Solve contracted strings of Tcol:
  id Tcol(i1?,i2?,a1?)*Tcol(i2?,i3?,a1?) = cF * dcol(i1,i3) ;

* Solve open strings of Tcol:
  id once Tcol(i1?,i2?,a1?)*Tcol(i2?,i3?,a2?) = dcol(i1,i3) * d_(a1,a2) /(2*nc) + (cold(a1,a2,tempa) + i_ * fcol(a1,a2,tempa)) * Tcol(i1,i3,tempa) / 2 ;
  sum tempa;

* Tcol is traceless:
  id Tcol(i1?,i1?,a1?) = 0 ;
endrepeat;
.sort

* now we can remove the dcols
dimension NcolF;
id dcol(i1?,i2?) = d_(i1,i2);
.sort

dimension NcolA;
* Solve some products of f,d

repeat;
* Eq 11 from Vermaseren color.pdf
  id fcol(a1?,a2?,a3?)*fcol(a4?,a2?,a3?)                   = cA * d_(a1,a4) ;

* Eq 44 from Vermaseren color.pdf
  id fcol(a1?,a2?,a4?)*fcol(a2?,a3?,a5?)*fcol(a3?,a1?,a6?) = cA/2 * fcol(a4,a5,a6) ;

  id cold(a1?,a2?,a3?)*fcol(a3?,a4?,a5?)*fcol(a5?,a6?,a1?) = - nc/2 * cold(a2,a4,a6) ;
  id cold(a1?,a2?,a3?)*cold(a3?,a4?,a5?)*fcol(a5?,a6?,a1?) = (nc^2-4)/(2*nc) * fcol(a2,a4,a6) ;
  id cold(a1?,a2?,a3?)*cold(a3?,a4?,a5?)*cold(a5?,a6?,a1?) = (nc^2-12)/(2*nc) * cold(a2,a4,a6) ;

  id cold(a1?,a2?,a3?)*cold(a1?,a2?,a4?) = (nc^2-4)/nc * d_(a3,a4) ;
  id fcol(a1?,a2?,a3?)*cold(a1?,a2?,a4?) = 0;

  id cold(a1?,a1?,a2?) = 0;
endrepeat;


.sort

* subsititue to traces over generators of the fundamental representation
repeat id fcol(a1?,a2?,a3?) = -2*i_*trSU(a1,a2,a3) + 2*i_*trSU(a1,a3,a2);
repeat id cold(a1?,a2?,a3?) = 2*trSU(a1,a2,a3) + 2*trSU(a1,a3,a2);

b trSU,d_;
.sort
Keep Brackets;



* apply Fierz identities
#do CC=1,1

  id trSU() = nc;
  id trSU(a1?) = 0;
  id trSU(a1?, a2?) = 1/2*d_(a1, a2);

  id trSU(?a1, a2?dummyindices_, ?a3, a2?, ?a4) = 1/2*(
    trSU(?a1, ?a4)*trSU(?a3) - nc^-1 * trSU(?a1, ?a3, ?a4)
  );

  id trSU(?a1, a2?dummyindices_, ?a3)*trSU(?a4, a2?, ?a5) = 1/2*(
    trSU(?a1, ?a5, ?a4, ?a3) - nc^-1 * trSU(?a1, ?a3)*trSU(?a4, ?a5)
  );

  if (match(trSU(?a1,a2?dummyindices_,?a3))) redefine CC "0"; 

  b trSU,d_;
  .sort
  Keep Brackets;

#enddo


.sort

if (count(trSU,1) > 0);
  Print "Could not resolve colour contractions due to: %t"; 
  exit; 
endif;

* substitute invariants of SU(nc)
id NcolA = (nc^2 - 1);
id NcolF = nc;
id cF    = (nc^2-1)/(2*nc);
id cA    = nc;

.sort

dimension d;

* vim: syntax=form
